import 'dart:io';
import 'package:path/path.dart' as path;
import 'package:flutter_openapi_generator/src/config/generator_config.dart';
import 'package:flutter_openapi_generator/src/models/endpoint_definition.dart';

class RepositoryGenerator {
  GeneratorConfig? _lastConfig;

  // Public entry: capture config for helper checks
  String generateRepository(
      String name, List<EndpointDefinition> endpoints, GeneratorConfig config) {
    _lastConfig = config;
    final code = _generateRepositoryInternal(name, endpoints, config);
    _lastConfig = null;
    return code;
  }

  // Actual implementation moved here
  String _generateRepositoryInternal(
      String name, List<EndpointDefinition> endpoints, GeneratorConfig config) {
    final className = '${_toPascalCase(name)}${config.naming.repositorySuffix}';
    final buffer = StringBuffer();

    // File header
    buffer.writeln('// Generated file. Do not edit.');
    buffer.writeln('// This file was generated by Flutter OpenAPI Generator');
    buffer.writeln('');

    // Imports
    buffer.writeln('import \'dart:convert\';');
    if (config.generation.addLogging) {
      buffer.writeln('import \'dart:developer\';');
    }

    // Import ApiClient with proper package path
    if (config.api.packageName != null &&
        config.api.apiClientImport.startsWith('lib/')) {
      // Convert lib/path to package:packageName/path
      final packagePath = config.api.apiClientImport.replaceFirst('lib/', '');
      buffer.writeln(
          'import \'package:${config.api.packageName}/$packagePath\';');
    } else {
      buffer.writeln('import \'${config.api.apiClientImport}\';');
    }
    buffer.writeln('');

    // Import models
    final modelImports = _getModelImports(endpoints, config);
    for (final import in modelImports) {
      buffer.writeln('import \'../models/$import\';');
    }
    buffer.writeln('');

    // Class definition
    buffer.writeln('class $className {');

    // Private apiClient field
    buffer.writeln('  final ApiClient _apiClient;');
    buffer.writeln('');

    // Constructor
    buffer.writeln('  $className(this._apiClient);');
    buffer.writeln('');

    // Methods
    for (final endpoint in endpoints) {
      final method = _generateMethod(endpoint, config);
      buffer.writeln(method);
      buffer.writeln('');
    }

    // Close class
    buffer.writeln('}');

    return buffer.toString();
  }

  String _generateMethod(EndpointDefinition endpoint, GeneratorConfig config) {
    final methodName = _generateMethodName(endpoint);
    final returnType = _getReturnType(endpoint);
    final parameters = _generateParameters(endpoint);
    final body = _generateMethodBody(endpoint, config);

    return '''  Future<$returnType> $methodName($parameters) async {
$body
  }''';
  }

  String _generateMethodName(EndpointDefinition endpoint) {
    if (endpoint.operationId != null &&
        endpoint.operationId!.trim().isNotEmpty) {
      return _sanitizeToCamelCase(endpoint.operationId!);
    }

    // Generate from path and method
    final pathParts =
        endpoint.path.split('/').where((part) => part.isNotEmpty).toList();
    final method = endpoint.method.toLowerCase();

    if (pathParts.isEmpty) {
      return method;
    }

    String name = method;
    for (final part in pathParts) {
      if (part.startsWith('{') && part.endsWith('}')) {
        final paramName = part.substring(1, part.length - 1);
        name += _toPascalCase(_sanitizeNonAlnumToSpace(paramName));
      } else {
        name += _toPascalCase(_sanitizeNonAlnumToSpace(part));
      }
    }

    return _toCamelCase(name);
  }

  String _getReturnType(EndpointDefinition endpoint) {
    final successResponse = endpoint.responses['200'] ??
        endpoint.responses['201'] ??
        (endpoint.responses.isNotEmpty
            ? endpoint.responses.values.first
            : null);

    if (successResponse == null || successResponse.type == 'dynamic') {
      return 'Map<String, dynamic>';
    }

    // Fallback if model file is missing
    if (!_modelFileExistsByType(successResponse.type, _lastConfig)) {
      return 'Map<String, dynamic>';
    }

    return successResponse.type;
  }

  String _generateParameters(EndpointDefinition endpoint) {
    final params = <String>[];

    for (final param
        in endpoint.parameters.where((p) => p.location == 'path')) {
      params.add('${param.type} ${param.name}');
    }

    // Add individual query parameters instead of a generic map
    for (final param
        in endpoint.parameters.where((p) => p.location == 'query')) {
      params.add('${param.type} ${param.name}');
    }

    if (endpoint.requestBody != null) {
      if (!_modelFileExistsByType(endpoint.requestBody!.type, _lastConfig)) {
        params.add('Map<String, dynamic> requestBody');
      } else {
        params.add('${endpoint.requestBody!.type} requestBody');
      }
    }

    return params.join(', ');
  }

  String _generateMethodBody(
      EndpointDefinition endpoint, GeneratorConfig config) {
    final buffer = StringBuffer();

    if (config.generation.addLogging) {
      buffer.writeln('    log(\'${endpoint.method} ${endpoint.path}\');');
    }

    // Build endpoint path with path params interpolated
    final pathWithParams = endpoint.path
        .replaceAllMapped(RegExp(r'\{([^}]+)\}'), (m) => '\$' + m[1]!);

    // Build query parameters string
    final queryParams =
        endpoint.parameters.where((p) => p.location == 'query').toList();
    String queryString = '';
    if (queryParams.isNotEmpty) {
      queryString = '?';
      final queryPairs = <String>[];
      for (final param in queryParams) {
        queryPairs.add('${param.name}=\${${param.name}}');
      }
      queryString += queryPairs.join('&');
    }

    // Make request using apiClient
    buffer.writeln('    try {');

    // Choose HTTP method
    final method = endpoint.method.toUpperCase();
    if (method == 'GET') {
      buffer.writeln(
          '      final response = await _apiClient.get(\'$pathWithParams$queryString\');');
    } else if (method == 'POST') {
      if (endpoint.requestBody != null) {
        if (!_modelFileExistsByType(endpoint.requestBody!.type, _lastConfig)) {
          buffer.writeln(
              '      final response = await _apiClient.post(\'$pathWithParams$queryString\', body: requestBody);');
        } else {
          buffer.writeln(
              '      final response = await _apiClient.post(\'$pathWithParams$queryString\', body: requestBody.toJson());');
        }
      } else {
        buffer.writeln(
            '      final response = await _apiClient.post(\'$pathWithParams$queryString\');');
      }
    } else if (method == 'PUT') {
      if (endpoint.requestBody != null) {
        if (!_modelFileExistsByType(endpoint.requestBody!.type, _lastConfig)) {
          buffer.writeln(
              '      final response = await _apiClient.put(\'$pathWithParams$queryString\', body: requestBody);');
        } else {
          buffer.writeln(
              '      final response = await _apiClient.put(\'$pathWithParams$queryString\', body: requestBody.toJson());');
        }
      } else {
        buffer.writeln(
            '      final response = await _apiClient.put(\'$pathWithParams$queryString\');');
      }
    } else if (method == 'DELETE') {
      buffer.writeln(
          '      final response = await _apiClient.delete(\'$pathWithParams$queryString\');');
    } else if (method == 'PATCH') {
      if (endpoint.requestBody != null) {
        if (!_modelFileExistsByType(endpoint.requestBody!.type, _lastConfig)) {
          buffer.writeln(
              '      final response = await _apiClient.patch(\'$pathWithParams$queryString\', body: requestBody);');
        } else {
          buffer.writeln(
              '      final response = await _apiClient.patch(\'$pathWithParams$queryString\', body: requestBody.toJson());');
        }
      } else {
        buffer.writeln(
            '      final response = await _apiClient.patch(\'$pathWithParams$queryString\');');
      }
    } else {
      if (endpoint.requestBody != null) {
        if (!_modelFileExistsByType(endpoint.requestBody!.type, _lastConfig)) {
          buffer.writeln(
              '      final response = await _apiClient.request(\'$method\', \'$pathWithParams$queryString\', body: requestBody);');
        } else {
          buffer.writeln(
              '      final response = await _apiClient.request(\'$method\', \'$pathWithParams$queryString\', body: requestBody.toJson());');
        }
      } else {
        buffer.writeln(
            '      final response = await _apiClient.request(\'$method\', \'$pathWithParams$queryString\');');
      }
    }

    buffer.writeln('');
    buffer.writeln(
        '      if (response.statusCode == 200 || response.statusCode == 201) {');

    if (config.generation.addLogging) {
      buffer.writeln('        log(\'API Response: \${response.body}\');');
    }

    final returnType = _getReturnType(endpoint);
    if (returnType == 'Map<String, dynamic>') {
      buffer.writeln('        final jsonResponse = jsonDecode(response.body);');
      buffer.writeln('        return jsonResponse;');
    } else {
      if (!_modelFileExistsByType(returnType, _lastConfig)) {
        buffer
            .writeln('        final jsonResponse = jsonDecode(response.body);');
        buffer.writeln('        return jsonResponse;');
      } else {
        buffer
            .writeln('        final jsonResponse = jsonDecode(response.body);');
        buffer.writeln('        return $returnType.fromJson(jsonResponse);');
      }
    }

    buffer.writeln('      } else {');
    buffer.writeln(
        '        throw Exception(\'Failed to ${endpoint.method.toLowerCase()} ${endpoint.path}: \${response.statusCode}\');');
    buffer.writeln('      }');
    buffer.writeln('    } catch (e) {');
    buffer.writeln(
        '      throw Exception(\'Failed to ${endpoint.method.toLowerCase()} ${endpoint.path}: \$e\');');
    buffer.writeln('    }');

    return buffer.toString();
  }

  List<String> _getModelImports(
      List<EndpointDefinition> endpoints, GeneratorConfig config) {
    final imports = <String>{};

    for (final endpoint in endpoints) {
      if (endpoint.requestBody != null &&
          endpoint.requestBody!.type != 'Map<String, dynamic>' &&
          !endpoint.requestBody!.type.startsWith('List<')) {
        if (_modelFileExistsByType(endpoint.requestBody!.type, config)) {
          final modelName = _toSnakeCase(endpoint.requestBody!.type);
          imports.add('$modelName.dart');
        }
      }

      for (final response in endpoint.responses.values) {
        if (response.type != 'dynamic' &&
            response.type != 'Map<String, dynamic>' &&
            !response.type.startsWith('List<')) {
          if (_modelFileExistsByType(response.type, config)) {
            final modelName = _toSnakeCase(response.type);
            imports.add('$modelName.dart');
          }
        }
      }
    }

    return imports.toList()..sort();
  }

  String _sanitizeToCamelCase(String input) {
    // Handle operationId format like "pastLesson.getAllPasstLessons"
    if (input.contains('.')) {
      final parts = input.split('.');
      if (parts.length >= 2) {
        // Take the last part and convert to camelCase
        final lastPart = parts.last;
        return _toCamelCase(lastPart);
      }
    }

    final cleaned = _sanitizeNonAlnumToSpace(input);
    final parts =
        cleaned.split(RegExp(r'\s+')).where((p) => p.isNotEmpty).toList();
    if (parts.isEmpty) return '';
    final first = parts.first.toLowerCase();
    final rest = parts.skip(1).map(_toPascalCase).join();
    return '$first$rest';
  }

  bool _modelFileExistsByType(String type, GeneratorConfig? config) {
    if (config == null) return false;
    final fileName = _toSnakeCase(type) + '.dart';
    final modelsDir =
        path.join(config.output.baseDirectory, config.output.modelsPath);
    final fullPath = path.join(modelsDir, fileName);
    return File(fullPath).existsSync();
  }

  String _sanitizeNonAlnumToSpace(String input) {
    return input.replaceAll(RegExp(r'[^A-Za-z0-9]+'), ' ');
  }

  String _toCamelCase(String input) {
    if (input.isEmpty) return input;
    return input[0].toLowerCase() + input.substring(1);
  }

  String _toPascalCase(String input) {
    if (input.isEmpty) return input;
    return input[0].toUpperCase() + input.substring(1).toLowerCase();
  }

  String _toSnakeCase(String input) {
    return input
        .replaceAllMapped(
            RegExp(r'([A-Z])'), (match) => '_${match.group(1)!.toLowerCase()}')
        .replaceFirst(RegExp(r'^_'), '');
  }
}
